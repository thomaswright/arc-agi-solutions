// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as JsxRuntime from "react/jsx-runtime";

function keepMapWithIndex(arr, f) {
  return Belt_Array.keepMap(arr.map(function (x, i) {
                  return [
                          x,
                          i
                        ];
                }), (function (param) {
                return f(param[0], param[1]);
              }));
}

function transpose(arr) {
  return Core__Array.reduceWithIndex(arr, [], (function (acc, cur, i) {
                if (i === 0) {
                  return cur.map(function (x) {
                              return [x];
                            });
                } else {
                  return acc.map(function (x, j) {
                              return Belt_Array.concatMany([
                                          x,
                                          [arr[i][j]]
                                        ]);
                            });
                }
              }));
}

function findLinesOfColor(full, color) {
  return keepMapWithIndex(full, (function (row, i) {
                if (row.every(function (c) {
                        return Caml_obj.equal(c, color);
                      })) {
                  return i;
                }
                
              }));
}

var allColors = [
  "Black",
  "Blue",
  "Red",
  "Green",
  "Yellow",
  "Gray",
  "Pink",
  "Orange",
  "Cyan",
  "Brown"
];

function colorToString(color) {
  switch (color) {
    case "Black" :
        return "Black";
    case "Blue" :
        return "Blue";
    case "Red" :
        return "Red";
    case "Green" :
        return "Green";
    case "Yellow" :
        return "Yellow";
    case "Gray" :
        return "Gray";
    case "Pink" :
        return "Pink";
    case "Orange" :
        return "Orange";
    case "Cyan" :
        return "Cyan";
    case "Brown" :
        return "Brown";
    
  }
}

function stringToColor(color) {
  switch (color) {
    case "Blue" :
        return "Blue";
    case "Brown" :
        return "Brown";
    case "Cyan" :
        return "Cyan";
    case "Gray" :
        return "Gray";
    case "Green" :
        return "Green";
    case "Orange" :
        return "Orange";
    case "Pink" :
        return "Pink";
    case "Red" :
        return "Red";
    case "Yellow" :
        return "Yellow";
    default:
      return "Black";
  }
}

function colorToHex(color) {
  switch (color) {
    case "Black" :
        return "#000";
    case "Blue" :
        return "#0074d9";
    case "Red" :
        return "#ff4136";
    case "Green" :
        return "#2ecc40";
    case "Yellow" :
        return "#ffdc00";
    case "Gray" :
        return "#aaa";
    case "Pink" :
        return "#f012be";
    case "Orange" :
        return "#ff851b";
    case "Cyan" :
        return "#7fdbff";
    case "Brown" :
        return "#870c25";
    
  }
}

function toColor(color) {
  switch (color) {
    case 1 :
        return "Blue";
    case 2 :
        return "Red";
    case 3 :
        return "Green";
    case 4 :
        return "Yellow";
    case 5 :
        return "Gray";
    case 6 :
        return "Pink";
    case 7 :
        return "Orange";
    case 8 :
        return "Cyan";
    case 9 :
        return "Brown";
    default:
      return "Black";
  }
}

function toColors(arr) {
  return arr.map(function (x) {
              return x.map(function (y) {
                          return toColor(y);
                        });
            });
}

function range(max) {
  return Core__Array.make(max + 1 | 0, 0).map(function (param, i) {
              return i;
            });
}

function converses(selects, max) {
  return range(max).filter(function (i) {
              return !selects.includes(i);
            });
}

function getLastEl(arr) {
  return arr[arr.length - 1 | 0];
}

function appendToLastEl(arr, x) {
  var lastIndex = arr.length - 1 | 0;
  return arr.map(function (e, i) {
              if (i === lastIndex) {
                return Belt_Array.concatMany([
                            e,
                            [x]
                          ]);
              } else {
                return e;
              }
            });
}

function groups(rows) {
  return Core__Array.reduce(rows, [], (function (acc, cur) {
                return Core__Option.mapOr(getLastEl(acc), [[cur]], (function (lastGroup) {
                              return Core__Option.mapOr(getLastEl(lastGroup), [[cur]], (function (lastEl) {
                                            if (lastEl === (cur - 1 | 0)) {
                                              return appendToLastEl(acc, cur);
                                            } else {
                                              return Belt_Array.concatMany([
                                                          acc,
                                                          [[cur]]
                                                        ]);
                                            }
                                          }));
                            }));
              }));
}

function maxes(full) {
  return [
          full.length - 1 | 0,
          transpose(full).length - 1 | 0
        ];
}

function allPairs(x, y) {
  return Belt_Array.concatMany(x.map(function (xv) {
                  return y.map(function (yv) {
                              return [
                                      xv,
                                      yv
                                    ];
                            });
                }));
}

function subSet(set, rows, cols) {
  return keepMapWithIndex(set, (function (x, i) {
                if (rows.includes(i)) {
                  return keepMapWithIndex(x, (function (y, j) {
                                if (cols.includes(j)) {
                                  return Caml_option.some(y);
                                }
                                
                              }));
                }
                
              }));
}

function getBlockSpecs(rows, cols) {
  var rowGroups = groups(rows);
  var colGroups = groups(cols);
  return allPairs(rowGroups, colGroups);
}

function carve(full, blockSpecs) {
  return blockSpecs.map(function (param) {
              return subSet(full, param[0], param[1]);
            });
}

function blocksNonBlackColor(blocks) {
  return blocks.map(function (block) {
              return [
                      block,
                      Core__Array.reduce(Belt_Array.concatMany(block), undefined, (function (acc, cur) {
                              if (Core__Option.isSome(acc) || cur === "Black") {
                                return acc;
                              } else {
                                return cur;
                              }
                            }))
                    ];
            });
}

function colorCount(arr) {
  return Core__Array.reduce(arr, undefined, (function (acc, cur) {
                return Belt_MapString.update(acc, colorToString(cur), (function (o) {
                              if (o !== undefined) {
                                return o + 1 | 0;
                              } else {
                                return 1;
                              }
                            }));
              }));
}

function compareBlocks(a, b) {
  var match = maxes(a);
  var match$1 = maxes(b);
  if (match[0] !== match$1[0] || match[1] !== match$1[1]) {
    return false;
  } else {
    return Core__Array.reduceWithIndex(a, true, (function (acc, row, i) {
                  return Core__Array.reduceWithIndex(row, acc, (function (acc2, el, j) {
                                if (acc2) {
                                  return Caml_obj.equal(el, b[i][j]);
                                } else {
                                  return false;
                                }
                              }));
                }));
  }
}

function isOnEdge(param, input) {
  var y = param[1];
  var x = param[0];
  var match = maxes(input);
  if (x === 0 || x === match[0] || y === 0) {
    return true;
  } else {
    return y === match[1];
  }
}

function keepMapAll(input, f) {
  return Belt_Array.keepMap(Belt_Array.concatMany(input.map(function (row, i) {
                      return row.map(function (el, j) {
                                  return f(el, i, j);
                                });
                    })), (function (o) {
                return o;
              }));
}

function getCoordsOfColors(input, colors) {
  return keepMapAll(input, (function (el, i, j) {
                if (colors.includes(el)) {
                  return {
                          x: i,
                          y: j,
                          color: el
                        };
                }
                
              }));
}

function reduceSatAll(arr, fs) {
  return Core__Array.reduce(arr, fs, (function (acc, arrEl) {
                var $$break = {
                  contents: false
                };
                return Core__Array.reduce(acc, [], (function (acc2, f) {
                              if (f(arrEl) && !$$break.contents) {
                                $$break.contents = true;
                                return acc2;
                              } else {
                                return Belt_Array.concatMany([
                                            acc2,
                                            [f]
                                          ]);
                              }
                            }));
              })).length === 0;
}

function blank(color, x, y) {
  return range(x).map(function (param) {
              return range(y).map(function (param) {
                          return color;
                        });
            });
}

function adjustRow(input, rowNum, f) {
  return input.map(function (row, i) {
              if (i === rowNum) {
                return row.map(f);
              } else {
                return row;
              }
            });
}

function adjustCol(input, colNum, f) {
  return input.map(function (row, i) {
              return row.map(function (el, j) {
                          if (j === colNum) {
                            return f(el);
                          } else {
                            return el;
                          }
                        });
            });
}

function isAt(a, b, param) {
  if ((a.x - param[0] | 0) === b.x) {
    return (a.y - param[1] | 0) === b.y;
  } else {
    return false;
  }
}

function isAEvery(coords, a, arr) {
  return arr.every(function (v) {
              return coords.some(function (b) {
                          return isAt(a, b, v);
                        });
            });
}

function getCorners(coords) {
  return Belt_Array.keepMap(coords, (function (a) {
                if (isAEvery(coords, a, [
                        [
                          0,
                          1
                        ],
                        [
                          -1,
                          0
                        ]
                      ])) {
                  return {
                          TAG: "TR",
                          _0: a
                        };
                } else if (isAEvery(coords, a, [
                        [
                          0,
                          1
                        ],
                        [
                          1,
                          0
                        ]
                      ])) {
                  return {
                          TAG: "TL",
                          _0: a
                        };
                } else if (isAEvery(coords, a, [
                        [
                          0,
                          -1
                        ],
                        [
                          -1,
                          0
                        ]
                      ])) {
                  return {
                          TAG: "BR",
                          _0: a
                        };
                } else if (isAEvery(coords, a, [
                        [
                          0,
                          -1
                        ],
                        [
                          1,
                          0
                        ]
                      ])) {
                  return {
                          TAG: "BL",
                          _0: a
                        };
                } else {
                  return ;
                }
              }));
}

function unwrapCorner(c) {
  return c._0;
}

function intMax(a, b) {
  if (Caml_obj.greaterthan(a, b)) {
    return a;
  } else {
    return b;
  }
}

function dist(a, b) {
  return intMax(a - b | 0, b - a | 0);
}

function getByCoord(input, param) {
  var y = param[1];
  return Core__Option.flatMap(input[param[0]], (function (row) {
                return row[y];
              }));
}

function stepsToNext(input, coord, color, param) {
  var yStep = param[1];
  var xStep = param[0];
  var match = maxes(input);
  var maxY = match[1];
  var maxX = match[0];
  var numSteps = 0;
  while((function () {
          var nextX = coord.x + Math.imul(xStep, numSteps) | 0;
          var nextY = coord.y + Math.imul(yStep, numSteps) | 0;
          var nextCoord = getByCoord(input, [
                nextX,
                nextY
              ]);
          return Core__Option.mapOr(nextCoord, false, (function (nextCoord) {
                        if (nextX >= 0 && nextX <= maxX && nextY >= 0 && nextY <= maxY) {
                          return nextCoord !== color;
                        } else {
                          return false;
                        }
                      }));
        })()) {
    numSteps = numSteps + 1 | 0;
  };
  return numSteps;
}

var testRaw = {
  input: [
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      4,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      4,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      8,
      1,
      1,
      1,
      4,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      1,
      1,
      1,
      4,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      8,
      1,
      1,
      1,
      4,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      4,
      4,
      4,
      4,
      4,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      3,
      3,
      1,
      3,
      3,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      3,
      1,
      1,
      1,
      3,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      3,
      1,
      1,
      1,
      3,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      3,
      3,
      1,
      3,
      3,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      6,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      1,
      1,
      1,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      6,
      1,
      1,
      1,
      1
    ]
  ],
  output: [
    [
      4,
      4,
      4,
      4,
      4,
      1,
      4,
      4,
      4,
      4,
      4
    ],
    [
      4,
      2,
      2,
      2,
      1,
      1,
      1,
      2,
      2,
      2,
      4
    ],
    [
      4,
      2,
      6,
      6,
      1,
      1,
      1,
      6,
      6,
      2,
      4
    ],
    [
      4,
      2,
      6,
      3,
      3,
      1,
      3,
      3,
      6,
      2,
      4
    ],
    [
      4,
      1,
      1,
      3,
      8,
      8,
      8,
      3,
      1,
      1,
      4
    ],
    [
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      1,
      1,
      1,
      1
    ],
    [
      4,
      1,
      1,
      3,
      8,
      8,
      8,
      3,
      1,
      1,
      4
    ],
    [
      4,
      2,
      6,
      3,
      3,
      1,
      3,
      3,
      6,
      2,
      4
    ],
    [
      4,
      2,
      6,
      6,
      1,
      1,
      1,
      6,
      6,
      2,
      4
    ],
    [
      4,
      2,
      2,
      2,
      1,
      1,
      1,
      2,
      2,
      2,
      4
    ],
    [
      4,
      4,
      4,
      4,
      4,
      1,
      4,
      4,
      4,
      4,
      4
    ]
  ]
};

var test_input = toColors(testRaw.input);

var test_output = toColors(testRaw.output);

var test = {
  input: test_input,
  output: test_output
};

function main(input) {
  var colorGroups = allColors.map(function (color) {
          return getCoordsOfColors(input, [color]);
        }).filter(function (coords) {
        return coords.length !== 0;
      });
  var match = Belt_Array.partition(colorGroups, (function (v) {
          return v.length === 1;
        }));
  var match$1 = Belt_Array.partition(match[1], (function (box) {
          return getCorners(box).length > 0;
        }));
  var bgColor = match$1[1][0][0].color;
  match$1[0].map(function (coords) {
        var corners = getCorners(coords);
        return corners.map(function (v) {
                    if (v.TAG !== "TL") {
                      return ;
                    }
                    var c = v._0;
                    stepsToNext(input, c, bgColor, [
                          0,
                          1
                        ]);
                    if (corners.length > 0) {
                      Core__Array.reduce(corners, 0, (function (acc, corner) {
                              var corner_ = corner._0;
                              return intMax(intMax(dist(corner_.x, c.x), dist(corner_.y, c.y)), acc);
                            }));
                      return ;
                    }
                    
                  });
      });
}

var output = main(test_input);

var Solution_4290ef0e = {
  testRaw: testRaw,
  test: test,
  main: main,
  output: output
};

var testRaw$1 = {
  input: [
    [
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      0,
      3,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      0
    ],
    [
      1,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      3,
      0,
      3,
      3,
      3,
      0,
      0,
      0
    ],
    [
      1,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      0,
      3,
      3,
      0,
      3,
      3,
      0,
      3,
      0,
      0
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      3,
      0,
      3,
      3,
      3,
      0,
      3,
      3
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      3,
      3,
      0,
      0,
      0,
      3,
      0,
      0,
      3
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      3,
      0,
      0,
      0,
      0,
      3,
      0,
      0,
      3,
      3,
      3,
      0,
      3,
      0,
      3,
      0,
      3
    ],
    [
      0,
      3,
      3,
      0,
      0,
      3,
      0,
      0,
      0,
      3,
      0,
      3,
      3,
      3,
      0,
      0,
      0
    ],
    [
      3,
      3,
      3,
      3,
      3,
      0,
      0,
      0,
      3,
      0,
      0,
      0,
      3,
      0,
      0,
      0,
      3
    ],
    [
      3,
      0,
      3,
      0,
      3,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      0,
      3
    ],
    [
      0,
      3,
      3,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      0,
      3,
      3,
      0
    ]
  ],
  output: [
    [
      1,
      1,
      1,
      1,
      0,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1,
      1
    ],
    [
      1,
      1,
      0,
      1,
      1,
      0
    ],
    [
      0,
      0,
      0,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1
    ]
  ]
};

var test_input$1 = toColors(testRaw$1.input);

var test_output$1 = toColors(testRaw$1.output);

var test$1 = {
  input: test_input$1,
  output: test_output$1
};

function main$1(input) {
  var blackRows = findLinesOfColor(input, "Black");
  var blackColumns = findLinesOfColor(transpose(input), "Black");
  var match = maxes(input);
  var blockSpecs = getBlockSpecs(converses(blackRows, match[0]), converses(blackColumns, match[1]));
  var blocks = carve(input, blockSpecs);
  return Core__Option.flatMap(Belt_MapString.findFirstBy(colorCount(Belt_Array.keepMap(blocksNonBlackColor(blocks), (function (param) {
                            return param[1];
                          }))), (function (k, v) {
                    return v === 1;
                  })), (function (param) {
                var k = param[0];
                return Core__Option.map(blocksNonBlackColor(blocks).find(function (param) {
                                return Core__Option.mapOr(param[1], false, (function (c) {
                                              return colorToString(c) === k;
                                            }));
                              }), (function (param) {
                              return param[0];
                            }));
              }));
}

var output$1 = main$1(test_input$1);

var Solution_0b148d64 = {
  test: test$1,
  output: output$1
};

var testRaw$2 = {
  input: [
    [
      0,
      0,
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      1,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      8,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      1,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      1
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2
    ],
    [
      8,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      0,
      0
    ]
  ],
  output: [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ]
};

var test_input$2 = toColors(testRaw$2.input);

var test_output$2 = toColors(testRaw$2.output);

var test$2 = {
  input: test_input$2,
  output: test_output$2
};

function main$2(input) {
  var hasOnlyFour = Belt_MapString.toArray(colorCount(Belt_Array.concatMany(input))).filter(function (param) {
        return param[1] === 4;
      });
  var color = hasOnlyFour.find(function (param) {
        return getCoordsOfColors(input, [stringToColor(param[0])]).every(function (c) {
                    return isOnEdge([
                                c.x,
                                c.y
                              ], input);
                  });
      });
  var match = maxes(input);
  var maxY = match[1];
  var maxX = match[0];
  return Core__Option.flatMap(color, (function (param) {
                var colorCoords = getCoordsOfColors(input, [stringToColor(param[0])]);
                if (reduceSatAll(colorCoords, [
                        (function (c) {
                            return c.x === 0;
                          }),
                        (function (c) {
                            return c.x === 0;
                          }),
                        (function (c) {
                            return c.x === maxX;
                          }),
                        (function (c) {
                            return c.x === maxX;
                          })
                      ])) {
                  var lefts = colorCoords.filter(function (c) {
                        return c.x === 0;
                      });
                  var rights = colorCoords.filter(function (c) {
                        return c.x === maxX;
                      });
                  var left0 = lefts[0];
                  var left1 = lefts[1];
                  var right0 = rights.find(function (r) {
                        return r.y === left0.y;
                      });
                  var right1 = rights.find(function (r) {
                        return r.y === left1.y;
                      });
                  if (right0 !== undefined && right1 !== undefined) {
                    return adjustCol(adjustCol(blank("Black", maxX, maxY), right0.y, (function (param) {
                                      return right0.color;
                                    })), right1.y, (function (param) {
                                  return right1.color;
                                }));
                  } else {
                    return ;
                  }
                }
                if (reduceSatAll(colorCoords, [
                        (function (c) {
                            return c.y === 0;
                          }),
                        (function (c) {
                            return c.y === 0;
                          }),
                        (function (c) {
                            return c.y === maxY;
                          }),
                        (function (c) {
                            return c.y === maxY;
                          })
                      ])) {
                  var tops = colorCoords.filter(function (c) {
                        return c.y === 0;
                      });
                  var bottoms = colorCoords.filter(function (c) {
                        return c.y === maxY;
                      });
                  var top0 = tops[0];
                  var top1 = tops[1];
                  var bottom0 = bottoms.find(function (b) {
                        return b.x === top0.x;
                      });
                  var bottom1 = bottoms.find(function (b) {
                        return b.x === top1.x;
                      });
                  if (bottom0 !== undefined && bottom1 !== undefined) {
                    return adjustRow(adjustRow(blank("Black", maxX, maxY), bottom0.x, (function (param) {
                                      return bottom0.color;
                                    })), bottom1.x, (function (param) {
                                  return bottom1.color;
                                }));
                  } else {
                    return ;
                  }
                }
                if (!reduceSatAll(colorCoords, [
                        (function (c) {
                            return c.x === 0;
                          }),
                        (function (c) {
                            return c.x === maxX;
                          }),
                        (function (c) {
                            return c.y === 0;
                          }),
                        (function (c) {
                            return c.y === maxY;
                          })
                      ])) {
                  return ;
                }
                var left = colorCoords.find(function (c) {
                      return c.x === 0;
                    });
                var top = colorCoords.find(function (c) {
                      return c.y === 0;
                    });
                if (left === undefined) {
                  return ;
                }
                if (top === undefined) {
                  return ;
                }
                var right = colorCoords.find(function (c) {
                      if (c.y === left.y) {
                        return c.x === maxX;
                      } else {
                        return false;
                      }
                    });
                var bottom = colorCoords.find(function (c) {
                      if (c.x === top.x) {
                        return c.y === maxY;
                      } else {
                        return false;
                      }
                    });
                if (right !== undefined && bottom !== undefined) {
                  return adjustRow(adjustCol(blank("Black", maxX, maxY), left.y, (function (param) {
                                    return left.color;
                                  })), top.x, (function (param) {
                                return top.color;
                              }));
                }
                
              }));
}

var output$2 = main$2(test_input$2);

var Solution_6cdd2623 = {
  testRaw: testRaw$2,
  test: test$2,
  main: main$2,
  output: output$2
};

function Solutions$Grid(props) {
  return JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx("div", {
                    children: props.block.map(function (row) {
                          return JsxRuntime.jsx("div", {
                                      children: row.map(function (el) {
                                            return JsxRuntime.jsx("div", {
                                                        className: "w-5 h-5",
                                                        style: {
                                                          backgroundColor: colorToHex(el)
                                                        }
                                                      });
                                          }),
                                      className: "flex flex-row gap-px"
                                    });
                        }),
                    className: "flex flex-col gap-px bg-gray-600 w-fit "
                  }),
              className: "p-2 "
            });
}

var Grid = {
  make: Solutions$Grid
};

function Solutions(props) {
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx(Solutions$Grid, {
                      block: test_input$1
                    }),
                Core__Option.mapOr(output$1, null, (function (output_) {
                        return JsxRuntime.jsxs("div", {
                                    children: [
                                      JsxRuntime.jsx(Solutions$Grid, {
                                            block: output_
                                          }),
                                      JsxRuntime.jsx(Solutions$Grid, {
                                            block: test_output$1
                                          }),
                                      JsxRuntime.jsx("div", {
                                            children: compareBlocks(output_, test_output$1) ? "Solved!" : "Unsolved",
                                            className: "p-2 font-black text-xl"
                                          })
                                    ]
                                  });
                      }))
              ],
              className: "flex flex-row"
            });
}

var Solution;

var make = Solutions;

export {
  keepMapWithIndex ,
  transpose ,
  findLinesOfColor ,
  allColors ,
  colorToString ,
  stringToColor ,
  colorToHex ,
  toColor ,
  toColors ,
  range ,
  converses ,
  getLastEl ,
  appendToLastEl ,
  groups ,
  maxes ,
  allPairs ,
  subSet ,
  getBlockSpecs ,
  carve ,
  blocksNonBlackColor ,
  colorCount ,
  compareBlocks ,
  isOnEdge ,
  keepMapAll ,
  getCoordsOfColors ,
  reduceSatAll ,
  blank ,
  adjustRow ,
  adjustCol ,
  isAt ,
  isAEvery ,
  getCorners ,
  unwrapCorner ,
  intMax ,
  dist ,
  getByCoord ,
  stepsToNext ,
  Solution_4290ef0e ,
  Solution_0b148d64 ,
  Solution_6cdd2623 ,
  Grid ,
  Solution ,
  make ,
}
/* test Not a pure module */
