// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as JsxRuntime from "react/jsx-runtime";

function keepMapWithIndex(arr, f) {
  return Belt_Array.keepMap(arr.map(function (x, i) {
                  return [
                          x,
                          i
                        ];
                }), (function (param) {
                return f(param[0], param[1]);
              }));
}

function transpose(arr) {
  return Core__Array.reduceWithIndex(arr, [], (function (acc, cur, i) {
                if (i === 0) {
                  return cur.map(function (x) {
                              return [x];
                            });
                } else {
                  return acc.map(function (x, j) {
                              return Belt_Array.concatMany([
                                          x,
                                          [arr[i][j]]
                                        ]);
                            });
                }
              }));
}

function findLinesOfColor(full, color) {
  return keepMapWithIndex(full, (function (row, i) {
                if (row.every(function (c) {
                        return Caml_obj.equal(c, color);
                      })) {
                  return i;
                }
                
              }));
}

function colorToString(color) {
  switch (color) {
    case "Black" :
        return "Black";
    case "Blue" :
        return "Blue";
    case "Red" :
        return "Red";
    case "Green" :
        return "Green";
    case "Yellow" :
        return "Yellow";
    case "Gray" :
        return "Gray";
    case "Pink" :
        return "Pink";
    case "Orange" :
        return "Orange";
    case "Cyan" :
        return "Cyan";
    case "Brown" :
        return "Brown";
    
  }
}

function colorToHex(color) {
  switch (color) {
    case "Black" :
        return "#000";
    case "Blue" :
        return "#0074d9";
    case "Red" :
        return "#ff4136";
    case "Green" :
        return "#2ecc40";
    case "Yellow" :
        return "#ffdc00";
    case "Gray" :
        return "#aaa";
    case "Pink" :
        return "#f012be";
    case "Orange" :
        return "#ff851b";
    case "Cyan" :
        return "#7fdbff";
    case "Brown" :
        return "#870c25";
    
  }
}

function toColor(color) {
  switch (color) {
    case 1 :
        return "Blue";
    case 2 :
        return "Red";
    case 3 :
        return "Green";
    case 4 :
        return "Yellow";
    case 5 :
        return "Gray";
    case 6 :
        return "Pink";
    case 7 :
        return "Orange";
    case 8 :
        return "Cyan";
    case 9 :
        return "Brown";
    default:
      return "Black";
  }
}

function toColors(arr) {
  return arr.map(function (x) {
              return x.map(function (y) {
                          return toColor(y);
                        });
            });
}

function range(max) {
  return Core__Array.make(max, 0).map(function (param, i) {
              return i;
            });
}

function converses(selects, max) {
  return range(max).filter(function (i) {
              return !selects.includes(i);
            });
}

function getLastEl(arr) {
  return arr[arr.length - 1 | 0];
}

function appendToLastEl(arr, x) {
  var lastIndex = arr.length - 1 | 0;
  return arr.map(function (e, i) {
              if (i === lastIndex) {
                return Belt_Array.concatMany([
                            e,
                            [x]
                          ]);
              } else {
                return e;
              }
            });
}

function groups(rows) {
  return Core__Array.reduce(rows, [], (function (acc, cur) {
                return Core__Option.mapOr(getLastEl(acc), [[cur]], (function (lastGroup) {
                              return Core__Option.mapOr(getLastEl(lastGroup), [[cur]], (function (lastEl) {
                                            if (lastEl === (cur - 1 | 0)) {
                                              return appendToLastEl(acc, cur);
                                            } else {
                                              return Belt_Array.concatMany([
                                                          acc,
                                                          [[cur]]
                                                        ]);
                                            }
                                          }));
                            }));
              }));
}

function dimensions(full) {
  return [
          full.length,
          transpose(full).length
        ];
}

function allPairs(x, y) {
  return Belt_Array.concatMany(x.map(function (xv) {
                  return y.map(function (yv) {
                              return [
                                      xv,
                                      yv
                                    ];
                            });
                }));
}

function subSet(set, rows, cols) {
  return keepMapWithIndex(set, (function (x, i) {
                if (rows.includes(i)) {
                  return keepMapWithIndex(x, (function (y, j) {
                                if (cols.includes(j)) {
                                  return Caml_option.some(y);
                                }
                                
                              }));
                }
                
              }));
}

function getBlockSpecs(rows, cols) {
  var rowGroups = groups(rows);
  var colGroups = groups(cols);
  return allPairs(rowGroups, colGroups);
}

function carve(full, blockSpecs) {
  return blockSpecs.map(function (param) {
              return subSet(full, param[0], param[1]);
            });
}

function blocksNonBlackColor(blocks) {
  return blocks.map(function (block) {
              return [
                      block,
                      Core__Array.reduce(Belt_Array.concatMany(block), undefined, (function (acc, cur) {
                              if (Core__Option.isSome(acc) || cur === "Black") {
                                return acc;
                              } else {
                                return cur;
                              }
                            }))
                    ];
            });
}

function colorCount(arr) {
  return Core__Array.reduce(arr, undefined, (function (acc, cur) {
                return Belt_MapString.update(acc, colorToString(cur), (function (o) {
                              if (o !== undefined) {
                                return o + 1 | 0;
                              } else {
                                return 1;
                              }
                            }));
              }));
}

function compareBlocks(a, b) {
  var match = dimensions(a);
  var match$1 = dimensions(b);
  if (match[0] !== match$1[0] || match[1] !== match$1[1]) {
    return false;
  } else {
    return Core__Array.reduceWithIndex(a, true, (function (acc, row, i) {
                  return Core__Array.reduceWithIndex(row, acc, (function (acc2, el, j) {
                                if (acc2) {
                                  return Caml_obj.equal(el, b[i][j]);
                                } else {
                                  return false;
                                }
                              }));
                }));
  }
}

var testRaw = {
  input: [
    [
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      0,
      3,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      0
    ],
    [
      1,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      3,
      0,
      3,
      3,
      3,
      0,
      0,
      0
    ],
    [
      1,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      0,
      3,
      3,
      0,
      3,
      3,
      0,
      3,
      0,
      0
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      3,
      0,
      3,
      3,
      3,
      0,
      3,
      3
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      3,
      3,
      0,
      0,
      0,
      3,
      0,
      0,
      3
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      3,
      0,
      0,
      0,
      0,
      3,
      0,
      0,
      3,
      3,
      3,
      0,
      3,
      0,
      3,
      0,
      3
    ],
    [
      0,
      3,
      3,
      0,
      0,
      3,
      0,
      0,
      0,
      3,
      0,
      3,
      3,
      3,
      0,
      0,
      0
    ],
    [
      3,
      3,
      3,
      3,
      3,
      0,
      0,
      0,
      3,
      0,
      0,
      0,
      3,
      0,
      0,
      0,
      3
    ],
    [
      3,
      0,
      3,
      0,
      3,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      0,
      3
    ],
    [
      0,
      3,
      3,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      0,
      3,
      3,
      0
    ]
  ],
  output: [
    [
      1,
      1,
      1,
      1,
      0,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1,
      1
    ],
    [
      1,
      1,
      0,
      1,
      1,
      0
    ],
    [
      0,
      0,
      0,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1
    ]
  ]
};

var test_input = toColors(testRaw.input);

var test_output = toColors(testRaw.output);

var test = {
  input: test_input,
  output: test_output
};

function main(input) {
  var blackRows = findLinesOfColor(input, "Black");
  var blackColumns = findLinesOfColor(transpose(input), "Black");
  var match = dimensions(input);
  var numCols = match[1];
  var numRows = match[0];
  var blockSpecs = getBlockSpecs(converses(blackRows, numRows), converses(blackColumns, numCols));
  console.log(blackRows, blackColumns, converses(blackRows, numRows), converses(blackColumns, numCols), blockSpecs);
  var blocks = carve(input, blockSpecs);
  return Core__Option.flatMap(Belt_MapString.toArray(colorCount(Belt_Array.keepMap(blocksNonBlackColor(blocks), (function (param) {
                              return param[1];
                            })))).find(function (param) {
                  return param[1] === 1;
                }), (function (param) {
                var k = param[0];
                return Core__Option.map(blocksNonBlackColor(blocks).find(function (param) {
                                return Core__Option.mapOr(param[1], false, (function (c) {
                                              return colorToString(c) === k;
                                            }));
                              }), (function (param) {
                              return param[0];
                            }));
              }));
}

var output = main(test_input);

var Solution_0b148d64 = {
  test: test,
  output: output
};

function Solutions$Grid(props) {
  return JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx("div", {
                    children: props.block.map(function (row) {
                          return JsxRuntime.jsx("div", {
                                      children: row.map(function (el) {
                                            return JsxRuntime.jsx("div", {
                                                        className: "w-5 h-5",
                                                        style: {
                                                          backgroundColor: colorToHex(el)
                                                        }
                                                      });
                                          }),
                                      className: "flex flex-col gap-px"
                                    });
                        }),
                    className: "flex flex-row gap-px bg-gray-600 w-fit "
                  }),
              className: "p-2 "
            });
}

var Grid = {
  make: Solutions$Grid
};

function Solutions(props) {
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx(Solutions$Grid, {
                      block: test_input
                    }),
                Core__Option.mapOr(output, null, (function (output_) {
                        return JsxRuntime.jsxs("div", {
                                    children: [
                                      JsxRuntime.jsx(Solutions$Grid, {
                                            block: output_
                                          }),
                                      JsxRuntime.jsx(Solutions$Grid, {
                                            block: test_output
                                          }),
                                      JsxRuntime.jsx("div", {
                                            children: compareBlocks(output_, test_output) ? "Solved!" : "Unsolved",
                                            className: "p-2 font-black text-xl"
                                          })
                                    ]
                                  });
                      }))
              ],
              className: "flex flex-row"
            });
}

var Solution;

var make = Solutions;

export {
  keepMapWithIndex ,
  transpose ,
  findLinesOfColor ,
  colorToString ,
  colorToHex ,
  toColor ,
  toColors ,
  range ,
  converses ,
  getLastEl ,
  appendToLastEl ,
  groups ,
  dimensions ,
  allPairs ,
  subSet ,
  getBlockSpecs ,
  carve ,
  blocksNonBlackColor ,
  colorCount ,
  compareBlocks ,
  Solution_0b148d64 ,
  Grid ,
  Solution ,
  make ,
}
/* test Not a pure module */
